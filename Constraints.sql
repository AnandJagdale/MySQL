-- CONSTRAINTS / RESTRICTION:- 
-- 1) Column level constraints:-
-- There is only one constraint ie; NOT NULL which can we apply on only column that why we called it is column level constraint
CREATE TABLE NEW_R(
EMP_ID INT UNSIGNED NOT NULL,
FIRST_NAME VARCHAR(50),
LAST_NAME VARCHAR(50));

DESC NEW_R

-- Insert data in table NEW_R
INSERT INTO NEW_R (EMP_ID, LAST_NAME) VALUES (100, 'JAGDALE'); 
SELECT * FROM NEW_R;

ALTER TABLE NEW_R MODIFY COLUMN FIRST_NAME VARCHAR(30) NOT NULL;
ALTER TABLE NEW_R MODIFY COLUMN FIRST_NAME VARCHAR(30);

DESC NEW_R;

-- UNIQUE
CREATE TABLE NEW_A(
EMP_ID INT UNSIGNED NOT NULL UNIQUE,
FIRST_NAME VARCHAR(40),
LAST_NAME VARCHAR(40));
DESC NEW_A;

INSERT INTO NEW_A(EMP_ID, FIRST_NAME, LAST_NAME) VALUES(101, 'ANAND', 'JAGDALE');
SELECT * FROM NEW_A;

INSERT INTO NEW_A(FIRST_NAME, LAST_NAME) VALUES('SAUDUL', 'HODA'); -- Getting error because we have already give the restriction by using constraint that EMP_ID INT UNSIGNED NOT NULL UNIQUE

-- 2) Table level constraints:-
-- When we want all unique data in table that time we apply table constraint like UNIQUE 
-- And once we apply table constraint it will apply on entire table means it can apply on the form of list of all column which are having in table
-- System will always remember or stored the constraint information by column name by default
-- But we can give the name to constraints
CREATE TABLE NEW_B(
EMP_ID INT UNSIGNED NOT NULL,
FIRST_NAME VARCHAR(50),
LAST_NAME VARCHAR(50),
UNIQUE (EMP_ID, FIRST_NAME, LAST_NAME));

-- System will always stored the information about constraint by column name by default here it has stored by EMP_ID column name by default
SELECT COLUMN_NAME, CONSTRAINT_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_NAME = 'NEW_B';

-- We can change the constraint name
-- 1ST METHOD
CREATE TABLE NEW_C(
EMP_ID INT UNSIGNED NOT NULL,
FIRST_NAME VARCHAR(45),
LAST_NAME VARCHAR(45),
CONSTRAINT UNIQ_CONSTRAINT UNIQUE(EMP_ID, FIRST_NAME, LAST_NAME));

SELECT COLUMN_NAME, CONSTRAINT_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_NAME = 'NEW_C';

-- 2ND METHOD
CREATE TABLE NEW_D(
EMP_ID INT UNSIGNED NOT NULL DEFAULT 0,
FIRST_NAME VARCHAR(51),
LAST_NAME VARCHAR(51));

ALTER TABLE NEW_D ADD UNIQUE(EMP_ID, FIRST_NAME, LAST_NAME);
SELECT COLUMN_NAME, CONSTRAINT_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_NAME = 'NEW_D';

-- 3RD METHOD WITH GIVING CONSTRAINT NAME
CREATE TABLE NEW_E(
EMP_ID INT UNSIGNED NOT NULL DEFAULT 0,
FIRST_NAME VARCHAR(30),
LAST_NAME VARCHAR(30));

ALTER TABLE NEW_E ADD CONSTRAINT UNIQUE_CONSTRAINT UNIQUE(EMP_ID, FIRST_NAME, LAST_NAME);
SELECT COLUMN_NAME, CONSTRAINT_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_NAME = 'NEW_E';

-- Insert the information the table
INSERT INTO NEW_E(FIRST_NAME, LAST_NAME) VALUES('VEDPRAKASH', 'ARYA');
SELECT * FROM NEW_E;


-- Primary key:-
-- The system will provide only one primary key for a one table
-- Primary key contains unique values which helps to identify other information based on that
-- We can apply the primary key to the list of column in  a one shot
-- Hence table constraint is important
-- The system will stored the information about primary key by name itself
-- And we can not change name primary key to other; Primary key is by default so we can not give name
-- 1ST METHOD:-
CREATE TABLE NEW_F(
EMP_ID INT UNSIGNED,
FIRST_NAME VARCHAR(50),
LAST_NAME VARCHAR(50),
ADHAAR VARCHAR(50),
PRIMARY KEY (EMP_ID, ADHAAR));

DESC NEW_F;

SELECT COLUMN_NAME, CONSTRAINT_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_NAME = 'NEW_F';

-- 2ND METHOD:-
CREATE TABLE NEW_G(
EMP_ID INT UNSIGNED,
FIRST_NAME VARCHAR(50),
LAST_NAME VARCHAR(50),
ADHAAR VARCHAR(15));

ALTER TABLE NEW_G ADD PRIMARY KEY (EMP_ID, ADHAAR);
SELECT COLUMN_NAME, CONSTRAINT_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_NAME = 'NEW_G';

ALTER TABLE NEW_G DROP PRIMARY KEY;
SELECT COLUMN_NAME, CONSTRAINT_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_NAME = 'NEW_G';


-- Foreign key:-
-- It establish relationship between two tables
-- There is need of build the relationship between table there is atleast one column should be unique
-- a) Parent table
-- It has already connected to database & then we have connect child table to parent table
-- b) Child table
-- We can give name to foreign key
-- D1_NEW:- PARENT TABLE [DEPARTMENT_ID INT UNSIGNED PRIMARY KEY]
CREATE TABLE D1_NEW(
DEPARTMENT_ID INT UNSIGNED PRIMARY KEY,
DEPARTMENT_NAME VARCHAR(50));

SELECT COLUMN_NAME, CONSTRAINT_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_NAME = 'D1_NEW';

-- E1_NEW:- CHILD TABLE [DEPARTMENT_ID INT UNSIGNED]
CREATE TABLE E1_NEW(
EMP_ID INT UNSIGNED PRIMARY KEY,
FIRST_NAME VARCHAR(50),
LAST_NAME VARCHAR(50),
SALARY DECIMAL(10,2),
DEPARTMENT_ID INT UNSIGNED,
FOREIGN KEY (DEPARTMENT_ID) REFERENCES D1_NEW(DEPARTMENT_ID));

SELECT COLUMN_NAME, CONSTRAINT_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_NAME = 'E1_NEW';

-- INSERT DATA:-
-- We can not insert a data into child table without taking permission of parent table
INSERT INTO E1_NEW VALUES(100, 'ANAND', 'JAGDALE', 25000, 99);

-- 09:50:19	INSERT INTO E1_NEW VALUES(100, 'ANAND', 'JAGDALE', 25000, 99)	Error Code: 1452. Cannot add or update a child row: a foreign key constraint fails (`hr`.`e1_new`, CONSTRAINT `e1_new_ibfk_1` FOREIGN KEY (`DEPARTMENT_ID`) REFERENCES `d1_new` (`DEPARTMENT_ID`))	0.047 sec

INSERT INTO D1_NEW VALUES(99, 'DATA_SCIENTIST');

-- Then we can insert a data into child table related to department_id(99) which is already having in a parent table
INSERT INTO E1_NEW VALUES(100, 'ANAND', 'JAGDALE', 25000, 99);

SELECT * FROM E1_NEW;

-- ON DELETE CASCADE:-
-- If delete even single value from parent table then what will happen in child table? entire row will be gone related to that value from child table

-- PARENT TABLE
CREATE TABLE DEPT(
DEPARTMENT_ID INT UNSIGNED PRIMARY KEY,
DEPARTMENT_NAME VARCHAR(50));
SELECT COLUMN_NAME, CONSTRAINT_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_NAME = 'DEPT';

-- CHILD TABLE
CREATE TABLE EMP(
EMP_ID INT UNSIGNED PRIMARY KEY,
FIRST_NAME VARCHAR(50),
LAST_NAME VARCHAR(50),
SALARY DECIMAL(10,2),
DEPARTMENT_ID INT UNSIGNED,
FOREIGN KEY (DEPARTMENT_ID) REFERENCES DEPT(DEPARTMENT_ID) ON DELETE CASCADE);

INSERT INTO DEPT VALUES(99, 'DATA ANALYST');
SELECT * FROM DEPT;

INSERT INTO EMP VALUES(100, 'ANAND', 'JAGDALE', 25000, 99);
SELECT *FROM EMP;

-- CROSS CHECK 
DELETE FROM DEPT
WHERE DEPARTMENT_ID = 99;

SELECT * FROM DEPT;
SELECT * FROM EMP;

-- ON DELETE SET NULL:-
-- If delete even single value from parent table then what will happen in child table? Only that value will be set as null in a child table

-- PARENT TABLE
CREATE TABLE DEP(
DEPARTMENT_ID INT UNSIGNED PRIMARY KEY,
DEPARTMENT_NAME VARCHAR(50));

-- PARENT TABLE
CREATE TABLE EM(
EMP_ID INT UNSIGNED PRIMARY KEY,
FIRST_NAME VARCHAR(50),
LAST_NAME VARCHAR(50),
SALARY DECIMAL(10,2),
DEPARTMENT_ID INT UNSIGNED,
FOREIGN KEY (DEPARTMENT_ID) REFERENCES DEP(DEPARTMENT_ID) ON DELETE SET NULL);

INSERT INTO DEP VALUES(99, 'IT_PROG');
SELECT * FROM DEP;

INSERT INTO EM VALUES(100, 'ANAND', 'JAGDALE', 25000, 99);
SELECT * FROM EM;

-- CROSS CHECK 
DELETE FROM DEP 
WHERE DEPARTMENT_ID = 99;

SELECT * FROM DEP;
SELECT * FROM EM;
-- ON UPDATE CASCADE:-
-- If we update any value in parent table then what will happen in child table? 
-- whatever we have upadted in parent table it will be reflected or updated automatically in child table

-- PARENT TABLE
CREATE TABLE DPT(
DEPARTMENT_ID INT UNSIGNED PRIMARY KEY,
DEPARTMENT_NAME VARCHAR(50));

-- CHILD TABLE 
CREATE TABLE EPE(
EMP_ID INT UNSIGNED PRIMARY KEY,
FIRST_NAME VARCHAR(50),
LAST_NAME VARCHAR(50),
SALARY DECIMAL(10,2),
DEPARTMENT_ID INT UNSIGNED,
FOREIGN KEY (DEPARTMENT_ID) REFERENCES DPT(DEPARTMENT_ID) ON UPDATE CASCADE); 

INSERT INTO DPT VALUES(99, 'PYTHON DEVELOPER');
SELECT * FROM DPT;

INSERT INTO EPE VALUES(100, 'ANAND', 'JAGDALE', 25000, 99);
SELECT * FROM EPE;

-- CROSS CHECK 
UPDATE DPT
SET DEPARTMENT_ID = 101
WHERE DEPARTMENT_ID = 99;

SELECT * FROM DPT;
SELECT * FROM EPE;